<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Circle of Fifths</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: sans-serif;
      background: #fafafa;
    }

    #circle {
      position: relative;
      width: 380px;
      height: 380px;
      margin-top: 30px;
    }

    .layer {
      position: absolute;
      top: 50%;
      left: 50%;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 0;
    }

    .fill.major       { width: 330px; height: 330px; background: #d0f0d0; }
    .fill.minor       { width: 260px; height: 260px; background: #d0e8ff; }
    .fill.diminished  { width: 180px; height: 180px; background: #fce0ec; }

    .ring {
      border: 1px solid black;
      background: transparent;
    }

    .ring.outer      { width: 330px; height: 330px; z-index: 3; }
    .ring.major      { width: 260px; height: 260px; z-index: 3; }
    .ring.minor      { width: 180px; height: 180px; z-index: 3; }
    .ring.diminished { width: 100px; height: 100px; z-index: 3; }

    .label {
      position: absolute;
      transform: translate(-50%, -50%);
      text-align: center;
      cursor: pointer;
      font-size: 12px;
      z-index: 4;
    }

    .major { font-weight: bold; font-size: 14px; }

    .separator {
      position: absolute;
      width: 1px;
      height: 165px;
      top: 7%;
      left: 50%;
      background: black;
      transform-origin: bottom center;
      z-index: 5;
    }

    #info {
      margin-top: 20px;
      font-size: 1.2em;
    }

    /* Red overlay styles */
    #red-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: auto;
      cursor: grab;
    }
    #red-canvas.dragging {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <h2>Circle of Fifths</h2>
  <div id="circle">
    <!-- Colored fills -->
    <div class="layer fill major"></div>
    <div class="layer fill minor"></div>
    <div class="layer fill diminished"></div>

    <!-- Circle ring outlines -->
    <div class="layer ring outer"></div>
    <div class="layer ring major"></div>
    <div class="layer ring minor"></div>
    <div class="layer ring diminished"></div>

    <!-- Red overlay (HTML/CSS only) -->
    <canvas id="red-canvas" width="380" height="380"></canvas>
  </div>
  <button id="toggle-labels" style="margin-top: 10px;">Show Roman Numerals</button>
  <button id="draw-arrow-mode" style="margin-top: 10px;">Draw Arrow by Steps</button>
  <div id="info">Click any chord to see its name.</div>

  <script>
    const majors = ['C', 'G', 'D', 'A', 'E', 'B', 'Gb/F♯', 'D♭', 'A♭', 'E♭', 'B♭', 'F'];
    const minors = ['Am', 'Em', 'Bm', 'F♯m', 'C♯m', 'G♯m', 'D♯m', 'B♭m', 'Fm', 'Cm', 'Gm', 'Dm'];
    const dims   = ['B°','F♯°','C♯°','G♯°','D♯°','A♯°','E♯°','D°','A°','E°','Bd♭°','Fd♭°'];

    const majors_roman = ['I', 'V', 'II', 'VI', 'III', 'VII', 'bV', 'bII', 'bVI', 'bIII', 'bVII', 'IV'];
    const minors_roman = ['vi', 'iii', 'vii', 'iv#', 'i#', 'vi#', 'biii', 'bvii', 'iv', 'i', 'v', 'ii'];
    const dims_roman = ['vii°', 'iv#°', 'i#°', 'v#°', 'vi#°', 'biii°', 'bvii°', 'iv°', 'i°', 'v°', 'ii°', 'vi°', 'iii°'];

    const circle = document.getElementById('circle');
    const info = document.getElementById('info');
    const toggleBtn = document.getElementById('toggle-labels');
    const drawArrowBtn = document.getElementById('draw-arrow-mode');
    let useRoman = false;
    let drawArrowMode = false;
    let arrowStep = 0;
    let arrowFrom = null;
    let arrowLabels = [];
    let arrows = [];
    let arrowCanvas = null;
    let arrowCtx = null;

    function polarToCartesian(cx, cy, r, angleDeg) {
      const rad = (angleDeg - 90) * Math.PI / 180;
      return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) };
    }

    const center = 190;
    const radii = { major: 150, minor: 110, dim: 70 };

    function drawLabels() {
      // Remove old labels
      Array.from(document.querySelectorAll('.label')).forEach(el => el.remove());
      majors.forEach((_, i) => {
        const angle = i * 30;
        const addLabel = (text, radius, className) => {
          const pos = polarToCartesian(center, center, radius, angle);
          const el = document.createElement('div');
          el.className = `label ${className}`;
          el.style.left = pos.x + 'px';
          el.style.top = pos.y + 'px';
          el.textContent = text;
          el.onclick = () => info.textContent = `${text} chord`;
          circle.appendChild(el);
        };
        addLabel(useRoman ? majors_roman[i] : majors[i], radii.major, 'major');
        addLabel(useRoman ? minors_roman[i] : minors[i], radii.minor, 'minor');
        addLabel(useRoman ? dims_roman[i] : dims[i], radii.dim, 'dim');
        const line = document.createElement('div');
        line.className = 'separator';
        line.style.transform = `rotate(${angle + 15}deg)`;
        circle.appendChild(line);
      });
    }
    drawLabels();

    toggleBtn.onclick = function() {
      useRoman = !useRoman;
      toggleBtn.textContent = useRoman ? 'Show Normal Labels' : 'Show Roman Numerals';
      drawLabels();
    };

    // --- Red Overlay Logic ---
    const redCanvas = document.getElementById('red-canvas');
    const ctx = redCanvas.getContext('2d');
    // Configurable: number of segments to cover (e.g., 5 for F-C-G)
    let coveredSegments = 3;
    // Configurable: which segment to start at (0 = C, 1 = G, ...)
    let startSegment = -1;
    // Number of total segments (12 for circle of fifths)
    const totalSegments = 12;
    // Arc radii (match your visual layers)
    const outerRadius = 165; // just inside the major ring
    const innerRadius = 90;  // just outside the diminished ring
    const diminishedRadius = 50; // inside the diminished ring (adjust as needed)
    const centerX = 190;
    const centerY = 190;
    function drawRedOverlay() {
      ctx.clearRect(0, 0, redCanvas.width, redCanvas.height);
      const anglePerSegment = 2 * Math.PI / totalSegments;
      // The arc should start and end at the segment boundaries, not centers
      const startAngle = -(anglePerSegment / 2) + (startSegment * anglePerSegment) - Math.PI / 2;
      const endAngle = -(anglePerSegment / 2) + ((startSegment + coveredSegments) * anglePerSegment) - Math.PI / 2;

      // Diminished arc: small notch at the center of the wedge
      const wedgeCenter = (startAngle + endAngle) / 2;
      const diminishedNotchSpan = Math.PI / 6; // 20 degrees total (10 deg each side)
      const diminishedStart = wedgeCenter - diminishedNotchSpan / 2;
      const diminishedEnd = wedgeCenter + diminishedNotchSpan / 2;

      ctx.save();
      ctx.beginPath();
      // Outer arc (segment boundary to boundary)
      ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
      // Line to inner arc (at end boundary)
      ctx.lineTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
      // Inner arc (reverse, from end boundary to just before the diminished notch)
      ctx.arc(centerX, centerY, innerRadius, endAngle, diminishedEnd, true);
      // Line to diminished arc (at diminishedEnd)
      ctx.lineTo(centerX + diminishedRadius * Math.cos(diminishedEnd), centerY + diminishedRadius * Math.sin(diminishedEnd));
      // Diminished arc (small arc at the bottom)
      ctx.arc(centerX, centerY, diminishedRadius, diminishedEnd, diminishedStart, true);
      // Line back to inner arc (at diminishedStart)
      ctx.lineTo(centerX + innerRadius * Math.cos(diminishedStart), centerY + innerRadius * Math.sin(diminishedStart));
      // Continue inner arc (reverse, from diminishedStart back to start boundary)
      ctx.arc(centerX, centerY, innerRadius, diminishedStart, startAngle, true);
      // Line to outer arc start
      ctx.lineTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));
      ctx.closePath();
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'red';
      ctx.stroke();
      ctx.restore();
    }
    drawRedOverlay();
    // --- Drag to rotate (snapping) ---
    let isDragging = false;
    let dragStartX = 0;
    let dragStartSegment = 0;
    redCanvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartSegment = startSegment;
      redCanvas.classList.add('dragging');
      document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStartX;
      // 1 full circle = 360px (approx for 380px circle), so 30deg = 30px
      const pxPerSegment = 380 / totalSegments;
      let deltaSegments = Math.round(dx / pxPerSegment);
      let newStart = (dragStartSegment + deltaSegments + totalSegments) % totalSegments;
      if (newStart !== startSegment) {
        startSegment = newStart;
        drawRedOverlay();
      }
    });
    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        redCanvas.classList.remove('dragging');
        document.body.style.userSelect = '';
      }
    });
    // Make it easy to change coveredSegments in code
    window.setRedOverlaySegments = (n) => {
      coveredSegments = n;
      drawRedOverlay();
    };
    window.setRedOverlayStart = (n) => {
      startSegment = n;
      drawRedOverlay();
    };

    // --- Arrow Mode Logic ---
    function createArrowCanvas() {
      if (!arrowCanvas) {
        arrowCanvas = document.createElement('canvas');
        arrowCanvas.width = 380;
        arrowCanvas.height = 380;
        arrowCanvas.style.position = 'absolute';
        arrowCanvas.style.top = '0';
        arrowCanvas.style.left = '0';
        arrowCanvas.style.pointerEvents = 'none';
        arrowCanvas.style.zIndex = 20;
        document.getElementById('circle').appendChild(arrowCanvas);
        arrowCtx = arrowCanvas.getContext('2d');
      }
    }

    function clearArrowCanvas() {
      if (arrowCtx) arrowCtx.clearRect(0, 0, 380, 380);
    }

    function drawAllArrows() {
      clearArrowCanvas();
      for (const [fromEl, toEl] of arrows) {
        drawArrow(fromEl, toEl, false);
      }
    }

    function highlightLabel(labelEl) {
      labelEl.style.boxShadow = '0 0 0 4px #0f0, 0 0 10px 4px #0f08';
      labelEl.style.borderRadius = '50%';
      labelEl.style.zIndex = 21;
    }
    function unhighlightLabel(labelEl) {
      labelEl.style.boxShadow = '';
      labelEl.style.zIndex = 4;
    }

    function drawArrow(fromEl, toEl, clear = false) {
      if (clear) clearArrowCanvas();
      if (!fromEl || !toEl) return;
      const fromRect = fromEl.getBoundingClientRect();
      const toRect = toEl.getBoundingClientRect();
      const circleRect = document.getElementById('circle').getBoundingClientRect();
      // Center of each label
      const fromX = fromRect.left + fromRect.width / 2 - circleRect.left;
      const fromY = fromRect.top + fromRect.height / 2 - circleRect.top;
      const toX = toRect.left + toRect.width / 2 - circleRect.left;
      const toY = toRect.top + toRect.height / 2 - circleRect.top;
      // Draw arrow line
      arrowCtx.save();
      arrowCtx.strokeStyle = '#0f0';
      arrowCtx.lineWidth = 4;
      arrowCtx.beginPath();
      arrowCtx.moveTo(fromX, fromY);
      arrowCtx.lineTo(toX, toY);
      arrowCtx.stroke();
      // Draw arrowhead
      const angle = Math.atan2(toY - fromY, toX - fromX);
      const headlen = 18;
      arrowCtx.beginPath();
      arrowCtx.moveTo(toX, toY);
      arrowCtx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 7), toY - headlen * Math.sin(angle - Math.PI / 7));
      arrowCtx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 7), toY - headlen * Math.sin(angle + Math.PI / 7));
      arrowCtx.lineTo(toX, toY);
      arrowCtx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 7), toY - headlen * Math.sin(angle - Math.PI / 7));
      arrowCtx.stroke();
      arrowCtx.restore();
    }

    function resetArrowMode() {
      arrowStep = 0;
      arrowFrom = null;
      arrowLabels.forEach(unhighlightLabel);
      arrowLabels = [];
      arrows = [];
      clearArrowCanvas();
    }

    drawArrowBtn.onclick = function() {
      drawArrowMode = !drawArrowMode;
      drawArrowBtn.textContent = drawArrowMode ? 'Cancel Arrow Drawing' : 'Draw Arrow by Steps';
      resetArrowMode();
      // Toggle pointer events on the red overlay canvas
      if (drawArrowMode) {
        if (redCanvas) redCanvas.style.pointerEvents = 'none';
      } else {
        if (redCanvas) redCanvas.style.pointerEvents = 'auto';
      }
      if (drawArrowMode) {
        createArrowCanvas();
        // Add click listeners to labels
        document.querySelectorAll('.label').forEach(label => {
          label.style.cursor = 'pointer';
          label.addEventListener('click', arrowLabelClick, {capture: true});
        });
        document.addEventListener('mousedown', arrowOutsideClick, {capture: true});
      } else {
        // Remove listeners and highlights
        document.querySelectorAll('.label').forEach(label => {
          label.style.cursor = '';
          label.removeEventListener('click', arrowLabelClick, {capture: true});
        });
        document.removeEventListener('mousedown', arrowOutsideClick, {capture: true});
        resetArrowMode();
        if (arrowCanvas) arrowCanvas.remove();
        arrowCanvas = null;
        arrowCtx = null;
      }
    };

    function arrowLabelClick(e) {
      e.stopPropagation();
      const label = e.currentTarget;
      if (arrowStep === 0) {
        resetArrowMode();
        highlightLabel(label);
        arrowLabels = [label];
        arrowFrom = label;
        arrowStep = 1;
      } else if (arrowStep === 1 && label !== arrowFrom) {
        highlightLabel(label);
        arrowLabels.push(label);
        arrows.push([arrowFrom, label]);
        drawAllArrows();
        // Prepare for next step
        arrowFrom = label;
        arrowStep = 1;
        arrowLabels = [arrowFrom];
      }
    }

    function arrowOutsideClick(e) {
      const circle = document.getElementById('circle');
      if (!circle.contains(e.target)) {
        resetArrowMode();
      }
    }

    // Redraw labels and re-attach listeners if in arrow mode
    const oldDrawLabels = drawLabels;
    drawLabels = function() {
      oldDrawLabels();
      if (drawArrowMode) {
        document.querySelectorAll('.label').forEach(label => {
          label.style.cursor = 'pointer';
          label.addEventListener('click', arrowLabelClick, {capture: true});
        });
        drawAllArrows();
      }
    }
  </script>
</body>
</html>
